## Write a monte carlo simulation that compute the pointwise MSE of the fitted
## values generated by npreg() using the newdata evaluation points
rm(list=ls())
library(np)
options(np.tree=TRUE,np.messages=FALSE)

M <- 1000
n.trials <- 2
n.vec <- c(100,200,400,800)
X.pred <- 0:2
dgp.pred <- sin(2.5*X.pred)
newdata.dgp <- data.frame(X=X.pred)
X.pred <- ordered(X.pred)
newdata <- data.frame(X=X.pred)

fitted.array.dgp <- array(NA,dim=c(length(n.vec),M,length(X.pred)))
fitted.array <- array(NA,dim=c(length(n.vec),M,length(X.pred)))

for(j in 1:length(n.vec)) {
  for(i in 1:M) {
    X <- sort(rbinom(n.vec[j],n.trials,.5))
    dgp <- sin(2.5*X)
    Y <- dgp + rnorm(n.vec[j],sd=sd(dgp))
    ghat.dgp <- lm(Y~sin(2.5*X))
    fitted.array.dgp[j,i,] <- predict(ghat.dgp,newdata=newdata.dgp)
    ghat.nw <- npreg(Y~ordered(X,levels=0:n.trials))
    fitted.array[j,i,] <- predict(ghat.nw,newdata=newdata)
  }
}

## Compute pointwise MSE at each support point

mse.dgp <- matrix(NA,nrow=length(n.vec),ncol=length(X.pred))
mse <- matrix(NA,nrow=length(n.vec),ncol=length(X.pred))
for(j in 1:length(n.vec)) {
  mse.dgp[j,] <- colMeans(sweep(fitted.array.dgp[j,,],2,dgp.pred)^2)
  mse[j,] <- colMeans(sweep(fitted.array[j,,],2,dgp.pred)^2)
}

matplot(n.vec,mse,type="l")
mse.dgp.pointwise <- numeric()
mse.pointwise <- numeric()
for(i in 1:length(X.pred)) {
  mse.dgp.pointwise[i] <- coef(lm(log(mse.dgp[,i])~log(n.vec)))[2]
  mse.pointwise[i] <- coef(lm(log(mse[,i])~log(n.vec)))[2]
}

mse.dgp.pointwise <- c(coef(lm(log(mse.dgp[,1])~log(n.vec)))[2],
                       coef(lm(log(mse.dgp[,2])~log(n.vec)))[2],
                       coef(lm(log(mse.dgp[,3])~log(n.vec)))[2])

mse.pointwise <- c(coef(lm(log(mse[,1])~log(n.vec)))[2],
                   coef(lm(log(mse[,2])~log(n.vec)))[2],
                   coef(lm(log(mse[,3])~log(n.vec)))[2])

par(mfrow=c(1,2))
plot(as.numeric(X.pred),mse.dgp.pointwise)
plot(as.numeric(X.pred),mse.pointwise)
